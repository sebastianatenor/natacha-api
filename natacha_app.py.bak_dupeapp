
from routes import ops_routes
from routes import ops_health
print('### DEBUG: imported ops_health OK')
import logging
import traceback
from fastapi.responses import PlainTextResponse
import os

from fastapi import FastAPI, Request

from routes.core_routes import router as core_router  # üëà NUEVO
from routes.embeddings_routes import router as embeddings_router
from routes.memory_routes import router as memory_router
from routes.ops_routes import router as ops_router
from routes.semantic_routes import router as semantic_router
from routes.tasks_routes import router as tasks_router

app = FastAPI()
app.include_router(ops_routes.router)
app.include_router(ops_health.router)
print('### DEBUG: mounted ops_health OK')

# ==== DEBUG RUNTIME CODE-ID ====
import importlib, inspect, hashlib, json
from fastapi.responses import JSONResponse, PlainTextResponse

@app.get("/__debug/codeid/tasks_routes")
def __debug_codeid_tasks_routes():
    try:
        mod = importlib.import_module("routes.tasks_routes")
        src = inspect.getsource(mod)
        path = inspect.getfile(mod)
        sha = hashlib.sha256(src.encode("utf-8")).hexdigest()[:16]
        return JSONResponse({"module":"routes.tasks_routes","file":path,"sha256_16":sha})
    except Exception as e:
        import traceback
        return PlainTextResponse(traceback.format_exc(), status_code=500)

@app.get("/__debug/routers")
def __debug_routers():
    out = []
    for r in app.router.routes:
        try:
            out.append({"path": r.path, "methods": sorted(list(r.methods))})
        except Exception:
            pass
    return JSONResponse(out)
# ==== END DEBUG ====
# app.include_router(tasks_router)  # via auto-discovery
# ==== AUTO-DISCOVERY DE ROUTERS ====
import pkgutil, importlib, inspect
from fastapi import APIRouter
import routes as _routes_pkg

def _load_routers():
    loaded = []
    for _, modname, _ in pkgutil.iter_modules(_routes_pkg.__path__):
        if not modname.endswith('_routes'):
            continue
        m = importlib.import_module(f'routes.{modname}')
        # buscar objetos APIRouter
        for name, obj in m.__dict__.items():
            if isinstance(obj, APIRouter):
                loaded.append((modname, name, obj))
    return loaded

# Mapa de prefijos por convenci√≥n (ajust√° lo que quieras)
_PREFIX_MAP = {
    'tasks_routes': '/tasks',
    'memory_routes': '/memory',
    'ops_routes': '/ops',
    'openapi_stable_routes': '',
    'system_routes': '/system',
    'context_routes': '/context',
    'profile_routes': '/profile',
    'knowledge_routes': '/knowledge',
    'intelligence_routes': '/intelligence',
    'auto_routes': '/auto',
}

_loaded = _load_routers()
for modname, name, rtr in _loaded:
    prefix = _PREFIX_MAP.get(modname, '')
    app.include_router(rtr, prefix=prefix, tags=getattr(rtr, 'tags', None))

# DEBUG: listar lo montado (ver secci√≥n B)
from fastapi.responses import JSONResponse
@app.get('/_debug/routes')
def _debug_routes():
    out = []
    for r in app.router.routes:
        if hasattr(r, 'path') and hasattr(r, 'methods'):
            out.append({
                'path': r.path,
                'methods': sorted(list(r.methods)),
                'name': getattr(r, 'name', None),
            })
    return JSONResponse(out)
# ==== FIN AUTO-DISCOVERY ====


# === DEBUG: handler global para ver stacktrace en 500 ===
@app.exception_handler(Exception)
async def _unhandled_exc(req: Request, exc: Exception):
    logging.exception("Unhandled exception in %s %s", req.method, req.url)
    return PlainTextResponse(traceback.format_exc(), status_code=500)
# === FIN DEBUG ===


@app.get("/health")
def health():
    return {"status": "ok", "message": "Natacha API base funcionando correctamente üöÄ"}


# memoria
# app.include_router(memory_router)  # via auto-discovery
# tareas
# app.include_router(tasks_router)  # via auto-discovery
# sem√°ntica
# app.include_router(semantic_router)  # via auto-discovery
# embeddings
# app.include_router(embeddings_router)  # via auto-discovery
# ops
# app.include_router(ops_router)  # via auto-discovery
# core / dashboard
app.include_router(core_router)  # üëà NUEVO

# === startup: cargar contexto operativo de Natacha ===
try:
    from intelligence.startup import load_operational_context

    api_base = os.getenv("NATACHA_CONTEXT_API")
    if not api_base:
        api_base = "http://127.0.0.1:8002"

    load_operational_context(api_base=api_base, limit=20)
except Exception as e:
    print(f"‚ö†Ô∏è Natacha startup context not loaded: {e}")

# ===== Bootstrap guard (local-friendly) =====
import os
try:
    from dotenv import load_dotenv  # opcional: pip install python-dotenv
    load_dotenv()
except Exception:
    pass

# Flags de entorno
REMOTE_BOOTSTRAP = os.getenv("NATACHA_REMOTE_BOOTSTRAP", "1") == "1"
REMOTE_BASE_URL = (os.getenv("REMOTE_BASE_URL") or "").rstrip("/")

from fastapi import FastAPI  # por si el import de arriba estaba antes

# Asegura que exista 'app' (si ya existe, no lo pisa)
try:
    app
except NameError:
    app = FastAPI()

@app.get("/")
def root():
    return {"service": "natacha-api", "ok": True}

@app.on_event("startup")
async def _guard_remote_bootstrap():
    """
    Evita que el fallo de endpoints remotos rompa el arranque local.
    """
    if not REMOTE_BOOTSTRAP:
        print("‚ÑπÔ∏è  Bootstrap remoto desactivado (NATACHA_REMOTE_BOOTSTRAP=0).")
        return
    if not REMOTE_BASE_URL:
        print("‚ö†Ô∏è  REMOTE_BASE_URL no configurada; saltando bootstrap remoto.")
        return
    try:
        # Ac√° ir√≠a tu fetch remoto si corresponde (lo dejamos noop en local)
        # p.ej.: requests.get(f"{REMOTE_BASE_URL}/ops/insights", timeout=5)
        pass
    except Exception as e:
        print(f"‚ö†Ô∏è  No se pudo cargar contexto remoto: {e}")
# ===== /Bootstrap guard =====


@app.get("/__debug/codeid/ops_routes")
def __debug_codeid_ops_routes():
    try:
        import importlib, inspect, hashlib
        from fastapi.responses import JSONResponse, PlainTextResponse
        mod = importlib.import_module("routes.ops_routes")
        src = inspect.getsource(mod)
        path = inspect.getfile(mod)
        sha = hashlib.sha256(src.encode("utf-8")).hexdigest()[:16]
        return JSONResponse({"module":"routes.ops_routes","file":path,"sha256_16":sha})
    except Exception:
        import traceback
        return PlainTextResponse(traceback.format_exc(), status_code=500)



@app.get("/__debug/routes")
def __debug_routes():
    return {"routes":[{"path": r.path, "name": getattr(r, "name", None)} for r in app.router.routes]}
